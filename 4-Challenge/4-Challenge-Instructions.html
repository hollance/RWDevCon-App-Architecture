<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>4-Challenge-Instructions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style id="mkstylesheet">
body{-webkit-font-smoothing:antialiased;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;margin:30px 0 0;padding:0;background:#fff}#wrapper{padding:20px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000}h2{color:#111}h3{color:#111;margin:0}h4{color:#111}h5{color:#111}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}a{color:#0d6ea1;text-decoration:none;-webkit-transition:color 0.2s ease-in-out;-moz-transition:color 0.2s ease-in-out;-o-transition:color 0.2s ease-in-out;-ms-transition:color 0.2s ease-in-out;transition:color 0.2s ease-in-out}a:hover{color:#3593d9}body{font-size:15px;line-height:21px;margin:0 auto}h1{font-size:37px;line-height:42px;margin-top:42px;margin-bottom:21px}h2{font-size:27px;line-height:42px;margin-top:42px;margin-bottom:21px}h3{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}h4{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}p,ul,ol,pre,table,blockquote{margin-top:21px;margin-bottom:21px}hr{border:1px solid;margin:-1px 0}ul ul,ol ol,ul ol,ol ul{margin-top:0;margin-bottom:0}b,strong,em,small,code{line-height:1}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}abbr,acronym{border-bottom:1px dotted #aaa}#wrapper img{max-width:100%;height:auto}dd{font-size:1em;margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 1.3125em;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:1.3;padding:.5em 1em 0}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;overflow:hidden;position:relative;margin:1em 0 2em}figcaption{font-style:italic;text-align:center;background:white;color:#666}.poetry pre{display:block;font-family:Georgia,Garamond,serif !important;font-size:110% !important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif !important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(200,200,200,0.25)}@media print{img,table,figure{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;padding:10px;position:relative;text-indent:0}}@media screen{.inverted{background:#252a2a}.inverted #wrapper{background:#252a2a;color:#eee}.inverted hr{border-color:#333f40 !important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dt,.inverted dd{color:#eee}.inverted pre{background:#ccc}.inverted pre code{color:#111}.inverted table{background:none}.inverted table tr:nth-child(odd),.inverted table td:nth-child(odd){background:none}.inverted a{color:#acd1d5}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7) !important;color:#eee !important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}}

@media print{
#generated-toc-clone,#generated-toc{display:none!important}
}
#generated-toc-clone li.missing,#mkreplaced-toc li.missing{list-style-type:none!important}#generated-toc-clone li, #mkreplaced-toc li{list-style-type:upper-roman}#generated-toc-clone li li, #mkreplaced-toc li li{list-style-type:decimal}#generated-toc-clone li li li,#mkreplaced-toc li li li{list-style-type:decimal-leading-zero}#generated-toc-clone li li li li,#mkreplaced-toc li li li li{list-style-type:lower-greek}#generated-toc-clone li li li li li,#mkreplaced-toc li li li li li{list-style-type:disc}#generated-toc-clone li li li li li li,#mkreplaced-toc li li li li li li{list-style-type:square}
</style>

</head>
<body class="normal firstload">
  <div id="wrapper">
      <h1 id="301:apparchitecturepart4:challengeinstructions">301: App Architecture, Part 4: Challenge Instructions</h1>

<p>So far you&#8217;ve done the following:</p>

<ul>
<li>You moved data and logic that relates to online auctions into the domain model.</li>
<li>You moved networking logic into the networking layer.</li>
<li>You put code that bridges the domain model and the networking layer into the application layer (the <code>PeriodicCheckForBids</code> class).</li>
</ul>

<p>But if you look at the full architecture diagram, there is still more you can do:</p>

<figure>
<img src="Images/TwoChallenges.png" alt="" />
</figure>

<p>We have two challenges for you:</p>

<ol>
<li><p>The persistence logic &#8211; loading and saving data &#8211; is mixed up with the domain model. You can extract this into a new &#8220;persistence layer&#8221; (also known as a &#8220;storage layer&#8221;).</p></li>
<li><p>The view controllers have code for formatting model data into human-readable form. You can move this &#8220;presentation logic&#8221; out of the view controller into separate classes.</p></li>
</ol>

<p>You probably won&#8217;t have time to do both, so pick the challenge you think is most fun. :]</p>

<h2 id="challengea:persistencelayer">Challenge A: Persistence Layer</h2>

<p>As you&#8217;ve heard many times in this talk, objects should ideally do one thing only. You have already moved a lot of the code out of the view controllers, but if you look at the domain model classes &#8211; <code>Watchlist</code>, <code>Item</code>, <code>Bid</code> &#8211; then you&#8217;ll notice that these objects actually do more than just domain jobs. </p>

<p>For example, in <strong>Item.swift</strong>:</p>

<ul>
<li><code>init(JSON)</code> converts JSON data into a new model object</li>
<li><code>init(coder)</code> has code for loading <code>Item</code> objects from a plist file</li>
<li><code>encodeWithCoder()</code> has code for saving the object to a plist file</li>
</ul>

<p>For a fairly simple app such as this it’s not such a big deal, but having this kind of logic inside the domain model tightly couples the models with a specific way of storing their data.</p>

<p>What if you want to change the datastore to SQLite or Core Data instead of a plist file? What if you can also receive new objects in XML or YAML format?</p>

<p>It’s best to keep format conversion and persistence logic far away from the model code, so that’s what you’ll do in this challenge.</p>

<p>IMPORTANT: Use the project from the <strong>4-Challenge A Starter</strong> folder.</p>

<h3 id="thedatastore">The DataStore</h3>

<p>The starter project includes a new <code>DataStore</code> class. This object is now responsible for loading and saving the <code>Watchlist</code>. </p>

<figure>
<img src="Images/DataStore.png" alt="" />
</figure>

<p>In <strong>Watchlist.swift</strong>, remove all the code from the <code>// MARK: Persistence</code> section.</p>

<p>Also replace <code>init()</code> with:</p>

<pre><code>init(items: [Item]) {  
  self.items = items  
}
</code></pre>

<p>In <strong>AppDelegate.swift</strong>, remove the following line:</p>

<pre><code>let watchlist = Watchlist()
</code></pre>

<p>Instead, you&#8217;ll make a new <code>DataStore</code> object and pass it to all the view controllers:</p>

<pre><code>let dataStore = DataStore()  
activityViewController.dataStore = dataStore  
...and so on...
</code></pre>

<p>From now on, to perform operations on the <code>Watchlist</code> object, your code can do something like:</p>

<pre><code>dataStore.watchlist.addItem(item)
</code></pre>

<p>Your job is to convert the code to use this new <code>DataStore</code> object.</p>

<p>(To save you some time, I&#8217;ve already converted <code>ItemDetailViewController</code>, <code>SearchViewController</code>, and <code>SettingsViewController</code>. The rest is up to you.)</p>

<h3 id="jsonconversion">JSON Conversion</h3>

<p>Both <strong>Item.swift</strong> and <strong>Bid.swift</strong> have an <code>init(JSON)</code> method that takes a dictionary and converts it into a domain model object.</p>

<p>Conversion between different data representations isn&#8217;t really something that belongs to the job description of the domain model. Even though the JSON data comes from the server, converting JSON to domain model objects is also not something that belongs in the network layer.</p>

<p>Instead, you&#8217;ll add the conversion logic in between these two:</p>

<figure>
<img src="Images/JSONConversion.png" alt="" />
</figure>

<p>Remove the <code>init(JSON)</code> method from <strong>Item.swift</strong> and <strong>Bid.swift</strong>.</p>

<p>A simple way to keep the existing code working without any changes, is to add these methods as <em>extensions</em> on <code>Item</code> and <code>Bid</code> into a new file, <strong>JSONConversion.swift</strong>.</p>

<p>Now <code>init(JSON)</code> is no longer officially part of the domain model, but you can still use it to convert from JSON. Very convenient!</p>

<p>When you&#8217;re done, <strong>Item.swift</strong> and <strong>Bid.swift</strong> shouldn&#8217;t have anything to do with JSON anymore (a search for &#8220;json&#8221; in these source files should have no hits).</p>

<h3 id="nscoding">NSCoding</h3>

<p><code>Item</code> and <code>Bid</code> also conform to <code>NSCoding</code>, which is where <code>init(coder)</code> and <code>encodeWithCoder()</code> come from. These methods are used to serialize the object into a plist, or to deserialize the plist data back into a domain object.</p>

<p>Ideally, <code>Item</code> and <code>Bid</code> do not know anything about <code>NSCoding</code>. </p>

<p>You might be tempted to move this code into an extension, just like you did with the JSON conversion logic. Unfortunately, Swift does not allow this.</p>

<p>Remove <code>init(coder)</code> and <code>encodeWithCoder()</code> from <strong>Item.swift</strong> and <strong>Bid.swift</strong>. These objects should no longer conform to <code>NSCoding</code>.</p>

<p>See if you can come up with a way to make <code>DataStore</code> load and save the <code>Item</code> and <code>Bid</code> objects.</p>

<p>Tip: One way to do this is to use temporary objects that exist just for loading and saving the domain objects. For example, you can make a new <code>SerializableItem</code> class that implements <code>NSCoding</code>. The only purpose of this class is to (de)serialize <code>Item</code> objects. After loading these <code>SerializableItem</code> objects from the plist, you convert them to real <code>Item</code> objects that go into the <code>Watchlist</code>.</p>

<figure>
<img src="Images/Serialization.png" alt="" />
</figure>

<p>Good luck!</p>

<p>Extra hard bonus challenge: Convert the app to use Core Data instead of plists. However, <code>Item</code> and <code>Bid</code> may not extend from <code>NSManagedObject</code>, and the view controllers should not require any changes (so you can&#8217;t give the view controllers an <code>NSManagedObjectContext</code> property).</p>

<h2 id="challengeb:presentationlayer">Challenge B: Presentation Layer</h2>

<p>Presentation logic is code that converts domain data into stuff that ends up on the screen. An obvious example of this is formatting an <code>NSDate</code> object into a string using <code>NSDateFormatter</code>.</p>

<p>There is an advantage to keeping the presentation logic separate from your view controllers: you can unit test it easier (no need to load the entire UI), and you can reuse the same logic across different view controllers (and possibly even different apps).</p>

<p>IMPORTANT: For this challenge, use the project from the <strong>4-Challenge B Starter</strong> folder.</p>

<h3 id="sortingtheitems">Sorting the items</h3>

<p>Why does the <code>sortItems()</code> method belong to <strong>Watchlist.swift</strong>? After all, it doesn&#8217;t matter to the domain model what order the <code>Item</code>s are in&#8230;</p>

<p>Of course, we sort the items so that we can list them alphabetically in the table view. But now we have a domain object that contains presentation logic. Naughty!</p>

<p>It doesn&#8217;t sound too harmful, surely &#8211; why shouldn’t <code>Watchlist</code> sort the items? Imagine that this same array of items is displayed in two different view controllers, but each wants to sort the list in a different way. Then you have a problem&#8230;</p>

<p>A domain object should only sort if that makes sense for the domain logic. But when it comes to drawing things on the screen, that is not the domain’s responsibility.</p>

<p>Remove <code>sortItems()</code> from <strong>Watchlist.swift</strong>.</p>

<p>This method is still being called from <strong>ItemDetailViewController.swift</strong>; also remove those lines.</p>

<p>Where should you sort the array now? If you&#8217;re not allowed to sort the list of items from <code>Watchlist</code>, then the only solution is to make a copy of that list and sort that copy.</p>

<figure>
<img src="Images/Presentation.png" alt="" />
</figure>

<p>I&#8217;ve already added a special helper class for this to the project: <strong>ListOfItems.swift</strong>.</p>

<p>In <strong>WatchViewController.swift</strong>, add a new instance variable:</p>

<pre><code>private var listOfItems = ListOfItems()
</code></pre>

<p>In <code>viewWillAppear()</code>, add the following line before reloading the table view:</p>

<pre><code>listOfItems = ListOfItems(items: watchlist.items)
</code></pre>

<p>This creates a new <code>ListOfItems</code> instance and gives it the <code>Item</code> objects from the <code>Watchlist</code>. The <code>ListOfItems</code> makes a copy of this array and sorts it.</p>

<p>In other words, <code>ListOfItems</code> is a presentation object. It contains the data from the domain model, but arranged for presentation on the screen.</p>

<p>Your job is to finish rewriting <strong>WatchViewController.swift</strong> so that it uses <code>listOfItems</code> instead of <code>watchlist.items</code>.</p>

<p>Tip: Because <code>Watchlist</code> is now unsorted and <code>ListOfItems</code> <em>is</em> sorted, you have to be careful. The object at index X in <code>Watchlist</code> may not be the same as the object at index X in <code>ListOfItems</code>.</p>

<h3 id="asmalltasteofmvvm">A small taste of MVVM</h3>

<p>MVVM, or Model-View-ViewModel, is an alternative for MVC. The difference is that you don&#8217;t put a controller between the model and the view, but a so-called <em>view model</em> (yes, the name is very confusing).</p>

<figure>
<img src="Images/ViewModel.png" alt="" />
</figure>

<p>A view model is a data model for the view. Whereas the domain model describes the core functionality of the app, the view model describes the contents (and behavior) of the user interface.</p>

<p>The reason for using a view model instead of a controller, is that view models are easier to unit test &#8211; you don&#8217;t need to load your entire UI &#8211; and you can often re-use them across different screens.</p>

<p>You&#8217;re now going to make a simple view model for the presentation logic from <strong>WatchViewController.swift</strong>. </p>

<p>The code in <code>tableView(cellForRowAtIndexPath)</code> converts the number of bidders and the highest bid amount into strings and then puts those strings into text labels. That is presentation logic. (By the way, the exact same thing happens in <strong>SearchViewController.swift</strong>, so that&#8217;s duplicate code.)</p>

<p>Add a new file to the project, named <strong>PresentationItem.swift</strong>. Add the following code to it:</p>

<pre><code>struct PresentationItem {  
  let itemNameText: String  
  let bidderCountText: String  
  let highestBidText: String

  init(item: Item) {  
    itemNameText = item.itemName

    if item.bids.count == 1 {  
      bidderCountText = &quot;1 Bidder&quot;  
    } else {  
      bidderCountText = &quot;\(item.bids.count) Bidders&quot;  
    }

    if let highestBid = item.highestBid {  
      highestBidText = currencyFormatter.stringFromNumber(highestBid.amount)!  
    } else {  
      highestBidText = &quot;-&quot;  
    }
  }  
}
</code></pre>

<p>This should look familiar; it contains the logic from <code>tableView(cellForRowAtIndexPath)</code>.</p>

<p><code>PresentationItem</code> is the view model for an <code>Item</code> displayed on the screen. It contains the data from <code>Item</code> but made human-readable.</p>

<p>You still need to add the code for <code>currencyFormatter</code> to this file (see <strong>WatchViewController.swift</strong>). </p>

<p>Your job is to make <code>WatchViewController.swift</code> use this new <code>PresentationItem</code> object to format <code>Item</code>s for display.</p>

<p>Do the same for <strong>SearchViewController.swift</strong>.</p>

<p>Tip: You can give <strong>ItemCell.swift</strong> a <code>configureForPresentationItem()</code> method that takes the strings from a <code>PresentationItem</code> object and places them into the cell&#8217;s text labels.</p>

<p>Good luck!</p>

<blockquote>
<p><strong>Note:</strong> If you wanted to unit test the presentation logic for this screen, all you&#8217;d need is <code>ListOfItems</code> and <code>PresentationItem</code>. If the values of the strings inside <code>PresentationItem</code> are correct, then you can be sure the UI is correct too. There is no need to unit test the actual view controller or the table view cells.</p>
</blockquote>
<!-- ##END MARKED WRAPPER## -->
    </div>
</body>
</html>